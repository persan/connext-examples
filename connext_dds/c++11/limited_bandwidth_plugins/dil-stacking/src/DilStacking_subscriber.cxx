/**
 * @file DilStacking_subscriber.cxx
 *
 * @brief Subscription example of type DilStacking.
 * @details This file is a modified version of the code generated by the
 * rtiddsgen command:
 *
 *      > rtiddsgen -platform universal -create examplefiles \
 *              -language C++11 -exampleTemplate advanced DilStacking.idl
 *
 * @note Even though we generated this file using platform universal, we don't
 * support the Limited Bandwidth Plugins for all of our platforms. We modified
 * this file to remove the platform-specific code for those architectures
 * on which we don't support the Limited Bandwidth Plugins.
 * We also removed the generated DataReader listener, as it was not used
 * in the example.
 * @see the README.txt file in the dil-stacking directory for further
 * information about how to compile and run this example.
 */

#include <algorithm>
#include <iostream>

#include <dds/sub/ddssub.hpp>
#include <dds/core/ddscore.hpp>
#include <rti/config/Logger.hpp>  // for logging
#include "DilStacking.hpp"
#include "application.hpp"  // for command line parsing and ctrl-c

int process_data(dds::sub::DataReader<DilStacking> reader)
{
    // Take all samples
    int count = 0;
    dds::sub::LoanedSamples<DilStacking> samples = reader.take();
    for (const auto& sample : samples) {
        if (sample.info().valid()) {
            count++;
            std::cout << sample.data() << std::endl;
        } else {
            std::cout << "Instance state changed to "
            << sample.info().state().instance_state() << std::endl;
        }
    }

    return count; 
} // The LoanedSamples destructor returns the loan

void run_subscriber_application(unsigned int domain_id, unsigned int sample_count)
{
    // Start communicating in a domain, usually one participant per application
    dds::domain::DomainParticipant participant(
        domain_id,
        dds::core::QosProvider::Default().participant_qos(
            "DilStacking_Library::DilStacking_Subscriber_Profile"));

    // Create a Topic with a name and a datatype
    dds::topic::Topic<DilStacking> topic(
        participant, 
        "Example DilStacking",
        dds::core::QosProvider::Default().topic_qos(
            "DilStacking_Library::DilStacking_Subscriber_Profile"));

    // Create a Subscriber
    dds::sub::Subscriber subscriber(
        participant,
        dds::core::QosProvider::Default().subscriber_qos(
            "DilStacking_Library::DilStacking_Subscriber_Profile"));

    // Create a DataReader, loading QoS profile from USER_QOS_PROFILES.xml.
    dds::sub::DataReader<DilStacking> reader(
        subscriber,
        topic,
        dds::core::QosProvider::Default().datareader_qos(
            "DilStacking_Library::DilStacking_Subscriber_Profile"));

    // Create a ReadCondition for any data received on this reader and set a
    // handler to process the data
    unsigned int samples_read = 0;
    dds::sub::cond::ReadCondition read_condition(
        reader,
        dds::sub::status::DataState::any(),
        [reader, &samples_read]() { samples_read += process_data(reader); });

    // WaitSet will be woken when the attached condition is triggered
    dds::core::cond::WaitSet waitset;
    waitset += read_condition;

    while (!application::shutdown_requested && samples_read < sample_count) {
        std::cout << "DilStacking subscriber sleeping up to 1 sec..." << std::endl;

        // Run the handlers of the active conditions. Wait for up to 1 second.
        waitset.dispatch(dds::core::Duration(1));
    }
}

int main(int argc, char *argv[])
{

    using namespace application;

    // Parse arguments and handle control-C
    auto arguments = parse_arguments(argc, argv);
    if (arguments.parse_result == ParseReturn::exit) {
        return EXIT_SUCCESS;
    } else if (arguments.parse_result == ParseReturn::failure) {
        return EXIT_FAILURE;
    }
    setup_signal_handlers();

    // Sets Connext verbosity to help debugging
    rti::config::Logger::instance().verbosity(arguments.verbosity);

    try {
        run_subscriber_application(arguments.domain_id, arguments.sample_count);
    } catch (const std::exception& ex) {
        // This will catch DDS exceptions
        std::cerr << "Exception in run_subscriber_application(): " << ex.what()
        << std::endl;
        return EXIT_FAILURE;
    }

    // Releases the memory used by the participant factory.  Optional at
    // application exit
    dds::domain::DomainParticipant::finalize_participant_factory();

    return EXIT_SUCCESS;
}
